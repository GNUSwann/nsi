<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>ShowCase</title>
		<style>
			html {
				color-scheme: light dark;
			}
			body {
				font-family: system-ui;
				font-size: 1.125rem;
				line-height: 1.5;
			}
			main {
				width: min(70ch, 100% - 4rem);
				margin-inline: auto;
			}
		</style>
	</head>
	<body>
		<main><h1>Projets NSI</h1><br><p>Je n'ai pas fait beaucoup de projets personnels en JavaScript (et aucun en Python) au cours de cette année. Ceci est donc une petite sélection des projets les plus simples et présentables.</p><br><p>À noter que ces projets ont été créés dans le respect de la convention générale établie pour ce qui est des commentaires. En effet, la convention ne veut aucun commentaire <strong>dans</strong> le programme (mis à part exceptions ou des "// TODO : ..." qui sont monnaie courante). Par contre, il arrive <strong>parfois</strong> qu'on retrouve <strong>au début</strong> du fichier une licence mise en commentaire ou quelques lignes expliquant précisément ce que fait cette partie du programme. Nous retrouvons aussi <strong>systématiquement</strong> un "README.md" à la racine de chaque projet expliquant la fonction et le fonctionnement général du programme, ainsi que quelques exemples d'utilisation.</p><br><p>Nous pouvons appuyer notre propos sur le top 15 des projets <a href="https://fr.wikipedia.org/wiki/GitHub">GitHub</a> (GitHub étant sans aucun doute la plateforme la plus populaire dans le milieu) les plus populaires pour prouver cette convention :</p><br><p>1. <a href="https://github.com/freeCodeCamp/freeCodeCamp">freeCodeCamp</a></p><p>2. <a href="https://github.com/EbookFoundation/free-programming-books">free-programming-books</a></p><p>3. <a href="https://github.com/jwasham/coding-interview-university">coding-interview-university</a></p><p>4. <a href="https://github.com/sindresorhus/awesome">awesome</a></p><p>5. <a href="https://github.com/kamranahmedse/developer-roadmap">developer-roadmap</a></p><p>6. <a href="https://github.com/public-apis/public-apis">public-apis</a></p><p>7. <a href="https://github.com/donnemartin/system-design-primer">system-design-primer</a></p><p>8. <a href="https://github.com/facebook/react">react</a></p><p>9. <a href="https://github.com/codecrafters-io/build-your-own-x">build-your-own-x</a></p><p>10. <a href="https://github.com/tensorflow/tensorflow">tensorflow</a></p><p>11. <a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a></p><p>12. <a href="https://github.com/trekhleb/javascript-algorithms">javascript-algorithms</a></p><p>13. <a href="https://github.com/twbs/bootstrap">bootstrap</a></p><p>14. <a href="https://github.com/vinta/awesome-python">awesome-python</a></p><p>15. <a href="https://github.com/ohmyzsh/ohmyzsh">ohmyzsh</a></p><br><p>On peut voir que certains dépôts, tels que "You-Dont-Know-JS", qui sont des e-books, ou encore "awesome", qui est une liste de dépôts, ne sont pas des dépôts pouvant justifier mes propos. Cependant, les autres dépôts respectent effectivement les conventions mentionnées précédemment.</p><br><h1>Liste des projets</h1><br><h2>1er Projet : Recurcive-reader</h2><p>Un projet JavaScript très simple qui a pour but de lire récursivement (c'est-à-dire dans tous les sous-dossiers) le nombre de lignes et de caractères de chaque fichier. Il a initialement été créé pendant une demi-heure de trou pendant laquelle je me demandais si <a href="https://bun.sh">Bun.js</a> battait aussi <a href="https://nodejs.org/en">Node.js</a> dans le domaine de la lecture d'éléments disque.</p><p>Je pense qu'à ce stade, Node.js n'a plus besoin d'être présenté. Mais bun.js est plutôt nouveau ; donc voici :</p><p>Bun.js est une alternative à Node.js qui a pour but d'être en tout point plus rapide que Node.js, qui est un interpréteur souvent critiqué pour sa lenteur (moins lent que Python, bien sûr). Bun.js se sert donc d'AppleWebKit (comparé à V8 chez Node.js) pour interpréter le JavaScript. AppleWebKit est connu pour sa rapidité d'interprétation, mais aussi pour son API beaucoup plus complexe (d'où le choix de V8 du côté de Node.js). Bun.js part déjà avec un gros avantage, mais en plus de ça, ce dernier est écrit en <a href="https://ziglang.org">Zig</a>, qui est un language de programation solide, statique, rapide, maintenable et plutôt jeune (2015).</p><br><h3><a href="https://github.com/RaphaelNJ/Recurcive-reader">Le code</a></h3><br><h2>2eme Projet : 3D_Window</h2><p>Un moteur graphique 3D (ou 2.5D) simple en utilisant la même technique de rendu que le tout premier jeu considéré comme 3D : Doom. Ayant perdu le projet original, je l'ai reconstruit cette fois-ci en JavaScript pour faciliter sa compréhension et sa vitesse d'écriture.</p><p>Doom utilise la technique de BSP pour la segementation de l'espace dans le but d'optimiser au maximum le chargement. Dans cette version, même si je m'inspire de l'idée générale, je divise seulement l'espace en secteurs.</p><p>Ce projet a vu le jour dans le but de prouver qu'il est possible de créer des jeux 3D avec un terminal (le jeu s'exécutait sur une invite de commande et les pixels étaient représentés par des caractères de couleur : "@" pour foncé, "#" pour moins foncé, "*" pour plus clair...). Le moteur s'appelait donc initialement "3D_Term" pour mettre l'accent sur son utilisation du terminal, mais il est maintenant appelé "3D_Window" car il s'exécute désormais dans le navigateur.</p><br><h3><a href="https://github.com/RaphaelNJ/3D_Window">Le code</a></h3><p><i>Si le nom des variables n'est pas assez explicite, il s'agit généralement de calculs mathématiques effectués. L'utilisation d'une seule lettre ou de quelques lettres pour représenter une valeur est donc courante. Je trouve d'ailleurs que mon système de nommage des variables est plus représentatif que celui du code <a href="https://github.com/id-Software/DOOM">original de Doom</a>. À noter que le code fourni contient des commentaires, ce qui est exceptionnel dans ce cas précis. Cela va jusqu'au point où id Software a dû se justifier :</i></p><code><p>Many thanks to Bernd Kreimeier for taking the time to clean up the project and make sure that it actually works. Projects tends to rot if you leave it alone for a few years, and it takes effort for someone to deal with it again.</p></code><p><i>La raison ? Le code est ancien et certaines parties sont illisibles car cela permet de maximiser l'optimisation du programme. Des commentaires étaient, <u>dans ce cas particulier</u>, nécessaires.</i></p><br><h2>3eme Projet : VisualScripting</h2><p>Ce projet est une alternative à Scratch qui offre une interface inspirée du blueprint d'Unreal Engine. J'ai entrepris ce projet parce que je trouvais Scratch peu ergonomique et difficile à comprendre pour les débutant. J'ai donc souhaité créer mon propre langage de programmation visuel, en m'inspirant de Blueprint (ou Blot, je crois, pour Unity), que je trouve déjà bien plus ergonomique. (le code restant le moyen le plus compréhensible, simple et ergonomique).</p><br><p>Ce projet permet de créer des programmes simples dans un langage de programmation visuel, puis de les compiler en JavaScript (contrairement à Scratch, qui est plus lent car il n'est pas compilé), afin de les exécuter directement dans le navigateur. Cependant, il est tout à fait possible de modifier le compilateur pour en faire un langage spécialisé dans la création de jeux vidéo (comme Scratch) ou dans l'automatisation (comme Node Red ou Tasker). Il suffit simplement de modifier le compilateur et tout est possible.</p><h3><strong><u>/!\</u></strong></h3><p>Il est important de noter que ce projet n'est qu'un ancien prototype et qu'il manque encore de nombreuses fonctionnalités. Il n'est pas prêt pour être utilisé en production et n'est pas optimisé. Son code n'est pas bien structuré. Heureusement, le projet est très court, ce qui facilite sa relecture. Le développement du projet final est bientôt finis et il est écrit en Rust (il conprend biensûr beaucoup plus de features). Le programme est donc axé sur la vélocitée plutôt que sur la scalabilité. J'ai donc apporté quelques modifications au projet, telles que le changement de noms de variables et la correction du code illisible, afin de le rendre plus compréhensible. La rédaction globale du projet étant médiocre, elle ne sert en aucun cas d'exemple.</p><h3><a href="https://github.com/RaphaelNJ/VisualScripting">Le code</a></h3><br><h2>4eme Projet : HTML Generator</h2><p>C'est le programme qui me permet d'écrire ces lignes. N'ayant ni le temps ni l'envie (et aussi en voulant étoffer ma liste de programmes à présenter), je viens de développer ce petit programme en Rust ce matin. Il s'agit d'un convertisseur Markdown vers HTML utilisant les regex. Il est équipé d'un petit serveur et d'un watcher (un élément de l'API Linux permettant d'être notifié lors de la modification d'un fichier. Utilisé pour relancer la convertion dès que le markdown est modifié) afin de visualiser en temps réel le rendu HTML.</p><br><p>À noter que ce programme n'a été testé exclusivement sur un environnement Linux. La compatibilité avec Windows ou Mac n'a donc pas été testée.</p><br><h3><a href="https://github.com/RaphaelNJ/md2html.rs">Le code</a></h3><br><h2>5eme Projet : Outils 2D</h2><p>Un simple moteur de jeu 2D utilisant Vite + TypeScript. Je ne me souviens pas réellement du contexte, mais cela a dû être un projet dont l'existence est uniquement justifiée par un ennui pendant l'ordre d'une demi-journée. Le projet n'est pas assez complet pour être nommé "moteur de jeu". L'appellation "Ensemble d'outils pour le développement de jeux 2D" serait plus fidèle. Il utilise l'API JavaScript Canvas pour dessiner les pixels à l'écran. Toute la logique concernant l'affichage est gérée directement par le programme.</p><br><p>Fonctionnalités :</p><p>- Dessiner un pixel.</p><p>- Dessiner une ligne (algorithme de la ligne de Bresenham).</p><p>- Dessiner n'importe quelle forme (algorithme de remplissage de polygones par scanline).</p><p>- Dessiner n'importe quelle image avec la possibilité d'appliquer une matrice de transformation linéaire (dérivé personnel de l'algorithme de rasterisation).</p><br><h3><a href="https://github.com/RaphaelNJ/Simple2DEngine.ts">Le code</a></h3></main>
	</body>
</html>
